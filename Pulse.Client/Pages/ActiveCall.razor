@page "/ActiveCall"
@using Pulse.Client.Calls
@using Pulse.Client.Audio
@inject CurrentCallAccessor CallAccessor
@inject Microphone Microphone
@inject Speaker Speaker

<MudGrid>
    <MudPaper Height="100%" Width="100%">
        <MudItem xs="12">
            <MudAvatar Color="Color.Primary" Size="Size.Large">@CurrentCall.OtherUser[0].ToString().ToUpper()</MudAvatar>
        </MudItem>
        <MudItem xs="12">
            <MudText Typo="Typo.h2">@CurrentCall.OtherUser</MudText>
        </MudItem>

        <MudItem xs="12">
            @if (!CurrentCall.Connection.IsCompleted)
            {
                <p>Connecting...</p>
                <MudProgressCircular Color="Color.Primary" Indeterminate="true"/>
            }
            else
            {
                <p>Connected!</p>
            }
            <MudIconButton Icon="@Icons.Filled.Phone" Color="Color.Error" Variant="Variant.Outlined" aria-label="hangup" OnClick="HangUp"></MudIconButton>
        </MudItem>

        @if (error is not null)
        {
            <p>@error</p>
        }
    </MudPaper>
</MudGrid>

@code {
    private Call CurrentCall => CallAccessor.CurrentCall!;
    private string? error;
    
    protected override async Task OnInitializedAsync()
    {
        try
        {
            await using var audioStream = await CurrentCall.Connection;
            StateHasChanged();
            var microphoneRecording = new CancellationTokenSource();
            _ = Task.Run(() => Microphone.RecordAsync(audioStream, microphoneRecording.Token));
            await Speaker.PlayAsync(audioStream); // Assuming the stream will end at the end of the call
            microphoneRecording.Cancel();
        }
        catch (Exception e)
        {
            error = e.ToString();
        }
    }

    private void HangUp()
    {
        throw new NotImplementedException();
    }

}