@page "/ActiveCall"
@using Pulse.Client.Calls
@using Pulse.Client.Audio
@inject CurrentCallAccessor CallAccessor
@inject Microphone Microphone
@inject Speaker Speaker
@inject NavigationManager NavigationManager

<MudPaper Class="pa-4 ma-4" Height="85vh">
    <MudStack Justify="Justify.Center" AlignItems="AlignItems.Center">
        <MudAvatar Color="Color.Primary" Size="Size.Large">@CurrentCall.OtherUser[0].ToString().ToUpper()</MudAvatar>
        <MudText Typo="Typo.h2">@CurrentCall.OtherUser</MudText>
        @if (!CurrentCall.Connection.IsCompleted)
        {
            <p>Connecting...</p>
            <MudProgressCircular Color="Color.Primary" Indeterminate="true"/>
        }
        else
        {
            <p>Connected!</p>
        }
        @if (error is not null)
        {
            <p>@error</p> // TODO: remove this
        }
        <MudIconButton Icon="@Icons.Filled.Phone" Color="Color.Error" Variant="Variant.Outlined" aria-label="hangup" OnClick="HangUpAsync"></MudIconButton>
    </MudStack>
</MudPaper>

@code {
    private Call CurrentCall => CallAccessor.CurrentCall!;
    private string? error;
    private Stream? callAudioStream;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            await using var audioStream = await CurrentCall.Connection;
            StateHasChanged();
            callAudioStream = audioStream;
            var microphoneRecording = new CancellationTokenSource();
            _ = Task.Run(() => Microphone.RecordAsync(audioStream, microphoneRecording.Token));
            await Speaker.PlayAsync(audioStream); // Assuming the stream will end at the end of the call
            microphoneRecording.Cancel();
            
            NavigationManager.NavigateTo("/");
        }
        catch (Exception e)
        {
            error = e.ToString();
        }
    }

    private async Task HangUpAsync()
    {
        if (callAudioStream != null)
            await callAudioStream.DisposeAsync(); // Will send hangup signal to the other user
        // todo: not working
    }
}